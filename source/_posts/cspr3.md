---
mathjax: true
title: CCF CSP 选拔模拟赛 Round 3
date: 2020-02-26 15:50:31
tags:
---

## A 快乐水

根据题意直接做就行，每次将剩余的钱除以3 得到可以买的快乐水瓶数，减去买水的钱
再加上用瓶子换回来的钱，直到剩下的钱不够买一瓶快乐水，即可求出答案。

## B A+B

首先用字符串进行一个模拟大数加法。

实现方法：将两个字符串进行反转，然后从低位往高位模拟，注意进位问题。

对数字进行打印则首先将每个数字对应的图形存起来，然后对应输出就可以了。

## C 让圣光净化一切

单调队列。如果直接找区间最大和并不是很好做，所以我们将数组转化为前缀和，那么只要求出最大的 $s_y  - s_x (y - x \le m)$。

然后我们用一个 `for` 循环来枚举右端点，每次枚举固定住右端点，然后枚举左端点，使得区间内骷髅数量不超过 $m$ 个 。

当右端点固定，即 $s_y$ 不变，枚举左端点，对于两个左端点 $j,k$，若有 $k < j$ 且 $s_k \ge s_j$，那么我们肯定不会选择 $k$ ，因为我们要求出 $s_y - s_x$ 最大， $s_y -  s_j \ge s_y - s_k$，且因为 $k$ 更加靠近 $y$ ，意味着我们可以选到更多 $y$ 后 面的骷髅，这就是单调性。

我们用双端队列 `std::deque` 来实现这个功能，每次入队一个 $i$ ，就删除前面所有不符合要求的骷髅（队列中骷髅序号 $k$ 当前序号 $i - m$，队列中骷髅序号 $k < m$ 且 $s_k \ge s_i$）。

## D 简单打牌

可以对每个玩家都记录着十种情况的其中的每种情况中的最大值，注意顺子的问题。然后分情况讨论就行了。

## E 魔法阵

AC 自动机。在建立字典树的时候记录每个字符串长度，即每个 now 的位置对应字符串
的长度。然后直接匹配，在匹配到相应的字符串时记录与当前字符相匹配的所有字符串起始
位置和终点位置。将所有取得的位置按末尾位置从小到大排序，贪心取出末尾位置更小的字
符串，记录 共能取出的数量即可。

## F 分糖果

我们使用前缀和，则从第 $i$ 个同学开始的 $b$ 个同学的糖果的数量和为 $pre(i+b-1)-pre(i-1)$。

因为是首尾相连的，所以分为两种情况。

1. $i+b-1 \le n$，则满足第 $i$ 个小朋友的要求的限制条件为 $pre(i+b-1)-pre(i-1) \ge c$；

2. $i+b-1 > n$，则满足第 $i$ 个小朋友的要求的限制条件为 $pre(n)+pre(i+b-1-n)-pre(i-1) \ge c$，移项：$pre(i+b-1-n)-pre(i-1) \ge c-pre(n)$。

可以看出这个是一个约束差分问题了，因为第二种情况的右边的值是不确定的。

所以我们二分枚举 $pre(n)$ 的值来判断是否有解，即判断是否能够满足所有小朋友的条件，同时 $pre(n)$ 也表示当前的答案。
