---
mathjax: true
title: 10th Contest
date: 2020-02-17 20:31:44
categories:
- 2020 冬季
---

恭喜徐杨世杰，章馨月，何家奇分别冠亚季军，宋凌宁获得集训队外第一。

## A Colorful Bricks

从 $n-1$ 个位置选 $k$ 个与前一个位置颜色不同，所以方案数为 $C(n-1,k)(m-1)^km$。

## B Equalizing by Division (hard version)

一个数操作任意次只会得到 $\log$ 个不同的值，所以直接暴力出得到 $x$ 需要的操作次数，然后遍历每个 $x$，取前 $k$ 小的操作数求和。

## C Count Pairs

两边同乘 $a_i-a_j$，然后将变量相同的移到一边，用 `std::map` 统计即可

## D Destroy the Colony

首先要求相同字母在同一侧，考虑在左侧的字母集合确定后，答案显然就是一个可重排列的计数，这个容易求出，设为$x$

$x$ 再乘个左侧字母集合的合法选择方案就是答案，如果不考虑询问的话，这个方案就是个 $01$ 背包问题，而现在每次询问就是多加了一个 $a$ 和 $b$ 这两种字母必须在同一个背包的条件，那么也就等价于 $a$ 和 $b$ 这两种字母都不能在其中一个背包出现，所以暴力 $a$ 和 $b$ 的情况，写一个删除背包预处理答案即可。

删除背包可以自行百度。

## E Array Beauty

首先beauty的定义和序列的顺序没关系，可以理解为定义在集合上的函数，然后又是求所有长度为 $k$ 的子序列的beauty和，所以 $a$ 的顺序并不影响答案，可以直接排序。

考虑求出beauty大于等于 $x$ 的方案数数组ans，做一下差分就能得到beauty恰好等于 $x$ 的方案数数组，然后循环一下统计答案即可

显然只有 $kx\le 100000$ 时，ans 数组的值才不为 $0$，考虑 DP 求解方案数，令 $dp(i,j)$ 表示以 $i$ 结尾，长度为 $j$ 的 beauty 大于等于$x$ 的方案数，转移时只要找到 $i$ 左边第一个小于等于 $a_i-x$ 的数即可，并维护一下 dp 值的前缀和就可以转移，复杂度是 $O(\frac{100000}{k}kn)$

然后上面 beauty 值的转化也能这样理解：$\sum f(x)=\sum\sum_{j=0}^{f(x)}1=\sum_{j=1}^{\max}\sum[f(x) \ge j]$，也就是求一个函数值的和，如果函数值值域不大就可以转化成求函数值大于等于$i$的方案数的和。
